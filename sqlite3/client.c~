#include "public.h"

/*
 * select 管理者
 * 思想：用select来管理多个IO，无事件，阻塞
 * 		一旦有其中一个IO或者多个IO 检测到了我们感兴趣的事件
 *		select 函数返回，返回值是检测到的事件个数
 *
 * */


/*
 * 功能：读取n个字节
 * 参数：
 * 		fd 文件描述符
 * 		buf 缓存首地址
 *		count 数量
 * 返回值：
 * 		成功：成功读取的字节数
 *		失败：-1
 * */
ssize_t readn(int fd ,void* buf,size_t count)
{
	size_t nleft = count;	//剩余未读字节数
	ssize_t nread;			//成功读取字节数
	char* bufp = (char*)buf;

	while(nleft > 0)
	{
		if((nread = read(fd,bufp,nleft)) < 0)
		{
			if(errno == EINTR)	//被信号中断
			{
				continue;
			}
			else
			{
				return -1;		//出错了
			}
		}
		else if(0 == nread)	//对等方关闭了
		{
			return count - nleft;
		}
		else{}
		bufp += nread;
		nleft -= nread;
	}
	return count;
}

/*
 *	写入n字节
 *
 * */

ssize_t writen(int fd,void* buf ,size_t count)
{
	size_t nleft = count;
	ssize_t nwriten;
	char* bufp = (char*) buf;
	while(nleft > 0)
	{
		//通常write不容易阻塞，只要缓冲区大于要发送的数据，
		//都能成功得将数据拷贝到发送缓冲区，不会阻塞
		if((nwriten = write(fd,bufp,nleft)) > 0)
		{
			if(errno == EINTR)
			{
				continue;
			}
			else
			{
				return -1;
			}
		}
		else if( 0 == nwriten)		//什么都没发生，继续
		{
			continue;
		}
		else{}
		bufp += nwriten;
		nleft-= nwriten;
	}
	return count;
}
int main(int argc, const char *argv[])
{
	//创建scoket
	int sockfd = socket(PF_INET,SOCK_STREAM,0);
	if(-1 == sockfd)
	{
		ERR_EXIT("socket");
	}
	//初始化服务器地址
	struct sockaddr_in servaddr;	//ipv4地址结构
	memset(&servaddr ,0,sizeof(servaddr)); 
	servaddr.sin_family = AF_INET;	//地址族
	servaddr.sin_port = htons(5188);	//断口号
	servaddr.sin_addr.s_addr = inet_addr("127.0.0.1"); //服务器地址
#if 0

	//将套接字与本地地址绑定
	if(bind(sockfd,(struct sockaddr*)&servaddr,sizeof(servaddr)) == -1)
	{
		ERR_EXIT("bind");
	}

#endif

	if(connect (sockfd,(struct sockaddr*)&servaddr,sizeof(servaddr))<0)
	{
		ERR_EXIT("connect");
	}
	printf("===========================================================\n");
	
	//struct XProtocol *recvbuf;
	packet_t recvbuf;
	packet_t sendbuf;
	int n;
	int ret;

	//char recvbuf[1024] = {0};
	//char sendbuf[1024] = {0};


	fd_set rset;	//读文件描述符集合
	FD_ZERO(&rset);	//清除所有文件描述符
	int maxfd;		//监控文件描述符中的最大值+1
	int nready;		//有事件IO的个数

	int fd_stdin = fileno(stdin);
	if(fd_stdin > sockfd)
	{
		maxfd = fd_stdin;
	}
	else
	{
		maxfd = sockfd;
	}
	while(1){
		//将需要监控的文件描述符加入到集合中
		FD_SET(sockfd,&rset);	//sockfd
		FD_SET(fd_stdin,&rset); //标准输入

		nready = select(maxfd+1,&rset,NULL,NULL,NULL);
		if(-1 == nready)
		{
			ERR_EXIT("select");
		}
		if(0 == nready)
		{
			//继续检测
			continue;
		}
		//判断socket 是否ready
		if(FD_ISSET(sockfd,&rset))
		{
			//sockfd 有输入
			memset(&recvbuf,0,sizeof(recvbuf));

			
			ret = readn(sockfd,&recvbuf.len,sizeof(recvbuf.len));
			if( -1 == ret)
			{
				ERR_EXIT("read");
			}
			else if(ret < 4)
			{
				printf("server close\n");
				break;
			}
			else{}
			
			n = ntohl(recvbuf.len);
			ret = readn(sockfd,&recvbuf,sizeof(recvbuf));
			if(-1 == ret){
				ERR_EXIT("read");
			}
			else if(ret < n)
			{
				printf("server close");
				break;
			}
			else{}
			printf("%s\n",recvbuf.text);
		}
		if(FD_ISSET(fd_stdin,&rset))
		{
			//标准输入有数据
			memset(&sendbuf,0,sizeof(sendbuf));

			if(fgets(sendbuf.text,sizeof(sendbuf.text),stdin) == NULL)
			{
				break;
			}
			n = strlen(sendbuf.text);
			sendbuf.len = htonl(n);
			writen(sockfd,&sendbuf,sizeof(sendbuf.len)+n);
		}
	}
	close(sockfd);
	return 0;
}
