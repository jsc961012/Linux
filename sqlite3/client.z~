#include "public.h"

/*
 * select 管理者
 * 思想：用select来管理多个IO，无事件，阻塞
 * 		一旦有其中一个IO或者多个IO 检测到了我们感兴趣的事件
 *		select 函数返回，返回值是检测到的事件个数
 *
 * */
int doService(int sockfd)
{
	struct XProtocol *recvbuf;
	struct XProtocol *sendbuf;
	//packet_t recvbuf;
	//packet_t sendbuf;
	int n;
	int ret;

	//char recvbuf[1024] = {0};
	//char sendbuf[1024] = {0};


	fd_set rset;	//读文件描述符集合
	FD_ZERO(&rset);	//清除所有文件描述符
	int maxfd;		//监控文件描述符中的最大值+1
	int nready;		//有事件IO的个数

	int fd_stdin = fileno(stdin);
	if(fd_stdin > sockfd)
	{
		maxfd = fd_stdin;
	}
	else
	{
		maxfd = sockfd;
	}
	while(1){
		unsigned char buffer[sizeof(struct XProtocol)];
		struct XProtocol *pxp;
		unsigned short cmd_type,rel_val;
		unsigned long data_len;
		char username[MAXLEN_USERNAME];


		//将需要监控的文件描述符加入到集合中
		FD_SET(sockfd,&rset);	//sockfd
		FD_SET(fd_stdin,&rset); //标准输入

		nready = select(maxfd+1,&rset,NULL,NULL,NULL);
		if(-1 == nready)
		{
			ERR_EXIT("select");
		}
		if(0 == nready)
		{
			//继续检测
			continue;
		}
		//判断socket 是否ready
		if(FD_ISSET(sockfd,&rset))
		{
			//sockfd 有输入
			memset(&recvbuf,0,sizeof(recvbuf));
			memset(buffer,0,sizeof(struct XProtocol));
			/*
			   ret  = readn(sockfd,&recvbuf->username,sizeof(recvbuf->username));
			//ret = readn(sockfd,&recvbuf.len,sizeof(recvbuf.len));
			if( -1 == ret)
			{
			ERR_EXIT("read");
			}
			else if(ret <= 0)
			{
			printf("server close\n");
			break;
			}
			else{}

			n = ntohl(recvbuf->data_len);
			ret = readn(sockfd,&recvbuf->data,n);
			//n = ntohl(recvbuf.len);
			//ret = readn(sockfd,&recvbuf.text,n);
			if(-1 == ret){
			ERR_EXIT("read");
			}
			else if(ret < n)
			{
			printf("server close");
			break;
			}
			else{}
			*/
			ret = read(sockfd,recvbuf->username,sizeof(recvbuf->username));
			if(ret == 0 )
			{
				printf("server close");
				break;
			}
			else{}

			read(sockfd,buffer,sizeof(struct XProtocol));
			recvbuf = (struct XProtocol*) buffer;
			printf("收到：%s\n",recvbuf->data);
			//printf("%s\n",recvbuf.text);
		}
		if(FD_ISSET(fd_stdin,&rset))
		{
			//标准输入有数据

			printf("输入用户名：\n");
			memset(&sendbuf,0,sizeof(sendbuf));
			memset(buffer,0,sizeof(struct XProtocol));
			
			sendbuf = (struct XProtocol *)buffer;
			scanf("%s",&username);
			printf("输入服务代号：\n");
			scanf("%o",&cmd_type);
			//if(fgets((char)cmd_type,sizeof((char)cmd_type),stdin)==NULL)
			//	break;
			//sendbuf->cmd_type = htons(cmd_type);
			strncpy(sendbuf->username,username,strlen(username));
			
			switch(cmd_type){
			case 1:
				//注册服务
				printf("发起注册服务");
				sendbuf->cmd_type = htons(REQ_Register);
				write(sockfd,sendbuf,sizeof(struct XProtocol));
				break;
			case 2:
				printf("发起登陆服务");
				sendbuf->cmd_type = htons(REQ_Login);
				write(sockfd,sendbuf,sizeof(struct XProtocol));

				break;
			case 3:
				printf("发起查询服务");
				sendbuf->cmd_type = htons(REQ_Query);
				write(sockfd,sendbuf,sizeof(struct XProtocol));
				break;
			case 4:
				printf("发起历史查询服务");
				sendbuf->cmd_type = htons(REQ_History);
				write(sockfd,sendbuf,sizeof(struct XProtocol));
				break;
			case 5:
				printf("发起退出服务");
				sendbuf->cmd_type = htons(REQ_Exit);
				write(sockfd,sendbuf,sizeof(struct XProtocol));
				break;
			}
			//n = strlen(sendbuf.text);
			//sendbuf.len = htonl(n);
			//writen(sockfd,&sendbuf,sizeof(sendbuf.len)+n);
		}
	}
}







/*
 * 功能：读取n个字节
 * 参数：
 * 		fd 文件描述符
 * 		buf 缓存首地址
 *		count 数量
 * 返回值：
 * 		成功：成功读取的字节数
 *		失败：-1
 * */
ssize_t readn(int fd ,void* buf,size_t count)
{
	size_t nleft = count;	//剩余未读字节数
	ssize_t nread;			//成功读取字节数
	char* bufp = (char*)buf;

	while(nleft > 0)
	{
		if((nread = read(fd,bufp,nleft)) < 0)
		{
			if(errno == EINTR)	//被信号中断
			{
				continue;
			}
			else
			{
				return -1;		//出错了
			}
		}
		else if(0 == nread)	//对等方关闭了
		{
			return count - nleft;
		}
		else{}
		bufp += nread;
		nleft -= nread;
	}
	return count;
}

/*
 *	写入n字节
 *
 * */

ssize_t writen(int fd,void* buf ,size_t count)
{
	size_t nleft = count;
	ssize_t nwriten;
	char* bufp = (char*) buf;
	while(nleft > 0)
	{
		//通常write不容易阻塞，只要缓冲区大于要发送的数据，
		//都能成功得将数据拷贝到发送缓冲区，不会阻塞
		if((nwriten = write(fd,bufp,nleft)) > 0)
		{
			if(errno == EINTR)
			{
				continue;
			}
			else
			{
				return -1;
			}
		}
		else if( 0 == nwriten)		//什么都没发生，继续
		{
			continue;
		}
		else{}
		bufp += nwriten;
		nleft-= nwriten;
	}
	return count;
}
int main(int argc, const char *argv[])
{
	//创建scoket
	int sockfd = socket(PF_INET,SOCK_STREAM,0);
	if(-1 == sockfd)
	{
		ERR_EXIT("socket");
	}
	//初始化服务器地址
	struct sockaddr_in servaddr;	//ipv4地址结构
	memset(&servaddr ,0,sizeof(servaddr)); 
	servaddr.sin_family = AF_INET;	//地址族
	servaddr.sin_port = htons(5188);	//断口号
	servaddr.sin_addr.s_addr = inet_addr("127.0.0.1"); //服务器地址
#if 0

	//将套接字与本地地址绑定
	if(bind(sockfd,(struct sockaddr*)&servaddr,sizeof(servaddr)) == -1)
	{
		ERR_EXIT("bind");
	}

#endif

	if(connect (sockfd,(struct sockaddr*)&servaddr,sizeof(servaddr))<0)
	{
		ERR_EXIT("connect");
	}
	printf("===========================================================\n");
	doService(sockfd);
	close(sockfd);
	return 0;
}
